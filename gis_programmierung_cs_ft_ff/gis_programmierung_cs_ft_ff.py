# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GisProgrammierungCSFTFF
                                 A QGIS plugin
 Das Plugin analysiert DGMs und reale Punktwolken auf folgende geometrischen Alogrithmen: "Konvexe Hülle", 
 "Punkt-in-Polygon-Test" und dem "Ear-Clipping-Algorithmus". Die Ergebnisse werden visualisert und einem Performancevergleich (m/s) unterzogen. 
 Hierbei wird eine große Anzahl von Geoobjekten (> 1.000.000) in eine relationale und Objektdatenbank gespeichert und eingelesen. 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-01-04
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Czarnach Simone, Feicht Tamara, Folger Florian
        email                : czarnach@hm.edu, Klein6@hm.edu, ffolger@hm.edu
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import QgsProject, Qgis

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .gis_programmierung_cs_ft_ff_dialog import GisProgrammierungCSFTFFDialog
import os.path
# Initalize for Ear-Clipping
import sys
import math

# Import vispy, laspy and numpy
import vispy
from vispy import app, gloo, visuals, scene
import laspy
from laspy.file import File
import numpy as np
import matplotlib.pyplot as plt

class GisProgrammierungCSFTFF:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GisProgrammierungCSFTFF_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GIS-Programmierung CS FT FF')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.
        We implement this ourselves since we do not inherit QObject.
        :param message: String for translation.
        :type message: str, QString
        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GisProgrammierungCSFTFF', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.
        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str
        :param text: Text that should be shown in menu items for this action.
        :type text: str
        :param callback: Function to be called when the action is triggered.
        :type callback: function
        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool
        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool
        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool
        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str
        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget
        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.
        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/gis_programmierung_cs_ft_ff/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Gis-Programmierung Plugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&GIS-Programmierung CS FT FF'),
                action)
            self.iface.removeToolBarIcon(action)

    def close_function(self):
        """Closing function"""
        self.dlg.close()

    # ------------- Convex Hull ------------- #
    def import_points_convexHull(self):
        """Convex Hull Import function"""
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select file","", '*.csv *.txt')
        self.dlg.ConvexHullImportPath.setText(filename) 
    
    def export_points_convexHull(self):
        """Convex Hull Export function"""
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select output file ","", '*.csv *.txt')
        self.dlg.ConvexHullExportPath.setText(filename)

    def execute_convexHull(self):
        """Main Convex Hull function, lesson 3"""
        filenameInConvHull = self.dlg.ConvexHullImportPath.text() # Filename Input
        filenameOutConvHull = self.dlg.ConvexHullExportPath.text() # Filename Output
        output_file_convHull = open(filenameOutConvHull, 'w')
        # Read file
        with open(filenameInConvHull, 'r') as file:
            S = np.genfromtxt(file, dtype=None)

        n = len(S)
        P = [None] * n
        l = np.where(S[:,0] == np.min(S[:,0]))
        pointOnHull = S[l[0][0]]

        def CCW(p1, p2, p3):
            """Function to know if we have a CCW turn (counter-clockwise)"""
            if (p3[1]-p1[1])*(p2[0]-p1[0]) >= (p2[1]-p1[1])*(p3[0]-p1[0]):
                return True
            return False

        i = 0
        while True:
            P[i] = pointOnHull
            endpoint = S[0]
            for j in range(1,n):
                if (endpoint[0] == pointOnHull[0] and endpoint[1] == pointOnHull[1]) or not CCW(S[j],P[i],endpoint):
                    endpoint = S[j]
            i = i + 1
            pointOnHull = endpoint
            if endpoint[0] == P[0][0] and endpoint[1] == P[0][1]:
                break

        for i in range(n):
            if P[-1] is None:
                del P[-1]
        P = np.array(P)
        np.savetxt(output_file_convHull, np.array(P), delimiter=' ', fmt='%f') #save File
        # Processing status in QGIS
        self.iface.messageBar().pushMessage("Success", "Output file written at " + filenameOutConvHull, level=Qgis.Success, duration=3)
        
        fig = plt.figure()
        ax = fig.add_subplot(111)  # vgl. https://matplotlib.org/api/_as_gen/matplotlib.pyplot.subplot.html (10.12.2018)
        # vgl. https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.set_ylim.html
        plt.ylim(-10, 15)
        plt.xlim(-10, 15)
        # vgl. https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html  
        plt.plot(P[:,0],P[:,1], 'b-')  # b = blau
        plt.plot([P[-1,0],P[0,0]],[P[-1,1],P[0,1]], 'b-')
        # Punkte in Hülle: rot
        plt.plot(S[:,0],S[:,1],"r^")
        # Punkte auf Hülle: grün + square marker
        plt.plot(P[:,0],P[:,1],"gs", markersize=7)
        # Koordinaten anzeigen
        for xy in zip(P[:,0],P[:,1]):                                                           
            ax.annotate('%s, %s' %xy, xy=xy, textcoords='data', ha='center', va='bottom', fontstyle='normal')   
        plt.axis('on')
        plt.title('Berechnung einer konvexen Hülle')
        plt.show()

    # ------------- Point in Polygon ------------- #
    def import_polygon_PIP(self):
        """Point in Polygon Import Polygon-function"""
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select file","", '*.ply *.txt')
        self.dlg.PolygonPIPImportPath.setText(filename)
        
    def import_points_PIP(self):
        """Point in Polygon Import Point-function"""
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select file","", '*.csv *.txt')
        self.dlg.PointPIPImportPath.setText(filename)

    def export_PIP(self):
        """Point in Poly Export function"""
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select output file ","", '*.ply *.txt')
        self.dlg.PIPExportPath.setText(filename)
    
    def execute_pip(self):
        """Main Point in Polygon function, lesson 2"""
        filenameInPIPPoints = self.dlg.PointPIPImportPath.text() # Filename Input Points
        filenameInPIPPoly = self.dlg.PolygonPIPImportPath.text() # Filename Input Points
        filenameOutPIP = self.dlg.PIPExportPath.text() # Filename Output

        output_file_PIP = open(filenameOutPIP, 'w')
        # Read file
        with open(filenameInPIPPoints, 'r') as file:
            pipPoints = np.genfromtxt(file, dtype=None) # pipPoints[0] = x, pipPoints[1] = y

        with open(filenameInPIPPoly, 'r') as file:
            pipPoly = np.genfromtxt(file, dtype=None, encoding='utf-8')
    
        print(pipPoints)
        n = len(pipPoly)
        N = len(pipPoints)
        P = [None] * N

        p1x,p1y = pipPoly[0]
        for i in range(n+1):
            p2x,p2y = pipPoly[i % n]
            for j in range(N):
                if pipPoints[j][1] > min(p1y,p2y):
                    if pipPoints[j][1] <= max(p1y,p2y):
                        if pipPoints[j][0] <= max(p1x,p2x):
                            if p1y != p2y:
                                xints = (pipPoints[j][1]-p1y)*(p2x-p1x)/(p2y-p1y)+p1x
                            if p1x == p2x or pipPoints[j][0] <= xints:
                                P[j] = (pipPoints[j][0], pipPoints[j][1])        
            p1x,p1y = p2x,p2y
        # Clear None
        Not_none_values = filter(None.__ne__, P)
        P = list(Not_none_values)
        P = np.array(P)
        print(P)

        # Save file
        np.savetxt(output_file_PIP, P, delimiter=' ', fmt='%f') #save File
        # Processing status in QGIS
        self.iface.messageBar().pushMessage("Success", "Output file written at " + filenameOutPIP, level=Qgis.Success, duration=3)
    
        # Plot data
        fig = plt.figure()
        ax = fig.add_subplot(111)  # vgl. https://matplotlib.org/api/_as_gen/matplotlib.pyplot.subplot.html (10.12.2018)
        # vgl. https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.set_ylim.html
        plt.ylim(-5, 15)
        plt.xlim(-5, 15)
        # vgl. https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html  
        plt.plot(pipPoly[:,0],pipPoly[:,1], 'b-')  # b = blau
        plt.plot([pipPoly[-1,0],pipPoly[0,0]],[pipPoly[-1,1],pipPoly[0,1]], 'b-')
        # Punkte in Hülle: rot
        plt.plot(P[:,0], P[:,1],"rx")
        # Koordinaten anzeigen
        for xy in zip(pipPoly[:,0],pipPoly[:,1]):                                                           
            ax.annotate('%s, %s' %xy, xy=xy, textcoords='data', ha='center', va='bottom', fontstyle='normal')     
        plt.axis('on')
        plt.title('Points in Polygon')
        plt.show()

    # ------------- Ear-Clipping-Algorithm  ------------- #
    def import_poly_ear(self):
        """Ear-Clipping-Algorithm import Polygon-function"""
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select file","", '*.ply *.txt')
        self.dlg.PolygonECAImportPath.setText(filename)

    def export_ear(self):
        """Ear-Clipping-Algorithm export Polygon-function"""
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select output file ","", '*.ply *.txt')
        self.dlg.EarClippingExportPath.setText(filename)

    def execute_ear(self):
        """Execute Ear-Clipping-Algorithm"""       
        filenameInEarClip = self.dlg.PolygonECAImportPath.text() # Filename Input Polygon
        filenameOutEarClip = self.dlg.EarClippingExportPath.text() # Filename Output

        output_file_EarClip = open(filenameOutEarClip, 'w')
        # Read file
        with open(filenameInEarClip, 'r') as file:
            ECAI = np.genfromtxt(file, dtype=None, encoding='utf-8')

        print(ECAI)
        n = len(ECAI)
        P = [None] * n
            
        # Algorithm
        def earcut(n, holeIndices=None, dim=None):
            dim = dim or 2

            hasHoles = holeIndices and len(holeIndices)
            outerLen =  holeIndices[0] * dim if hasHoles else len(n)
            outerNode = linkedList(n, 0, outerLen, dim, True)
            triangles = []

            if not outerNode:
                return triangles

            minX = None
            minY = None
            maxX = None
            maxY = None
            x = None
            y = None
            size = None

            if hasHoles:
                outerNode = eliminateHoles(n, holeIndices, outerNode, dim)

            # if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
            if (len(shape) > 80 * dim):
                minX = maxX = n[0]
                minY = maxY = n[1]

                for i in range(dim, outerLen, dim):
                    x = n[i]
                    y = n[i + 1]
                    if x < minX:
                        minX = x
                    if y < minY:
                        minY = y
                    if x > maxX:
                        maxX = x
                    if y > maxY:
                        maxY = y

                # minX, minY and size are later used to transform coords into integers for z-order calculation
                size = max(maxX - minX, maxY - minY)

            earcutLinked(outerNode, triangles, dim, minX, minY, size)

            return triangles


        # create a circular doubly linked _list from polygon points in the specified winding order
        def linkedList(n, start, end, dim, clockwise):
            i = None
            last = None

            if (clockwise == (signedArea(n, start, end, dim) > 0)):
                for i in range(start, end, dim):
                    last = insertNode(i, n[i], n[i + 1], last)

            else:
                for i in reversed(range(start, end, dim)):
                    last = insertNode(i, n[i], n[i + 1], last)

            if (last and equals(last, last.next)):
                removeNode(last)
                last = last.next

            return last


        # eliminate colinear or duplicate points
        def filterPoints(start, end=None):
            if not start:
                return start
            if not end:
                end = start

            p = start
            again = True

            while again or p != end:
                again = False

                if (not p.steiner and (equals(p, p.next) or area(p.prev, p, p.next) == 0)):
                    removeNode(p)
                    p = end = p.prev
                    if (p == p.next):
                        return None

                    again = True

                else:
                    p = p.next

            return end

        # main ear slicing loop which triangulates a polygon (given as a linked _list)
        def earcutLinked(ear, triangles, dim, minX, minY, size, _pass=None):
            if not ear:
                return

            # interlink polygon nodes in z-order
            if not _pass and size:
                indexCurve(ear, minX, minY, size)

            stop = ear
            prev = None
            next = None

            # iterate through ears, slicing them one by one
            while ear.prev != ear.next:
                prev = ear.prev
                next = ear.next

                if isEarHashed(ear, minX, minY, size) if size else isEar(ear):
                    # cut off the triangle
                    triangles.append(prev.i // dim)
                    triangles.append(ear.i // dim)
                    triangles.append(next.i // dim)

                    removeNode(ear)

                    # skipping the next vertice leads to less sliver triangles
                    ear = next.next
                    stop = next.next

                    continue

                ear = next

                # if we looped through the whole remaining polygon and can't find any more ears
                if ear == stop:
                    # try filtering points and slicing again
                    if not _pass:
                        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1)

                        # if this didn't work, try curing all small self-intersections locally
                    elif _pass == 1:
                        ear = cureLocalIntersections(ear, triangles, dim)
                        earcutLinked(ear, triangles, dim, minX, minY, size, 2)

                        # as a last resort, try splitting the remaining polygon into two
                    elif _pass == 2:
                        splitEarcut(ear, triangles, dim, minX, minY, size)

                    break

        # check whether a polygon node forms a valid ear with adjacent nodes
        def isEar(ear):
            a = ear.prev
            b = ear
            c = ear.next

            if area(a, b, c) >= 0:
                return False # reflex, can't be an ear

            # now make sure we don't have other points inside the potential ear
            p = ear.next.next

            while p != ear.prev:
                if pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) and area(p.prev, p, p.next) >= 0:
                        return False
                p = p.next

            return True

        def isEarHashed(ear, minX, minY, size):
            a = ear.prev
            b = ear
            c = ear.next

            if area(a, b, c) >= 0:
                return False # reflex, can't be an ear

            # triangle bbox; min & max are calculated like this for speed
            minTX = (a.x if a.x < c.x else c.x) if a.x < b.x else (b.x if b.x < c.x else c.x)
            minTY = (a.y if a.y < c.y else c.y) if a.y < b.y else (b.y if b.y < c.y else c.y)
            maxTX = (a.x if a.x > c.x else c.x) if a.x > b.x else (b.x if b.x > c.x else c.x)
            maxTY = (a.y if a.y > c.y else c.y) if a.y > b.y else (b.y if b.y > c.y else c.y)

            # z-order range for the current triangle bbox;
            minZ = zOrder(minTX, minTY, minX, minY, size)
            maxZ = zOrder(maxTX, maxTY, minX, minY, size)

            # first look for points inside the triangle in increasing z-order
            p = ear.nextZ

            while p and p.z <= maxZ:
                if p != ear.prev and p != ear.next and pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) and area(p.prev, p, p.next) >= 0:
                    return False
                p = p.nextZ

            # then look for points in decreasing z-order
            p = ear.prevZ

            while p and p.z >= minZ:
                if p != ear.prev and p != ear.next and pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) and area(p.prev, p, p.next) >= 0:
                    return False
                p = p.prevZ

            return True

        # go through all polygon nodes and cure small local self-intersections
        def cureLocalIntersections(start, triangles, dim):
            do = True
            p = start

            while do or p != start:
                do = False

                a = p.prev
                b = p.next.next

                if not equals(a, b) and intersects(a, p, p.next, b) and locallyInside(a, b) and locallyInside(b, a):
                    triangles.append(a.i // dim)
                    triangles.append(p.i // dim)
                    triangles.append(b.i // dim)

                    # remove two nodes involved
                    removeNode(p)
                    removeNode(p.next)

                    p = start = b

                p = p.next

            return p

        # try splitting polygon into two and triangulate them independently
        def splitEarcut(start, triangles, dim, minX, minY, size):
            # look for a valid diagonal that divides the polygon into two
            do = True
            a = start

            while do or a != start:
                do = False
                b = a.next.next

                while b != a.prev:
                    if a.i != b.i and isValidDiagonal(a, b):
                        # split the polygon in two by the diagonal
                        c = splitPolygon(a, b)

                        # filter colinear points around the cuts
                        a = filterPoints(a, a.next)
                        c = filterPoints(c, c.next)

                        # run earcut on each half
                        earcutLinked(a, triangles, dim, minX, minY, size)
                        earcutLinked(c, triangles, dim, minX, minY, size)
                        return

                    b = b.next

                a = a.next

        # link every hole into the outer loop, producing a single-ring polygon without holes
        def eliminateHoles(n, holeIndices, outerNode, dim):
            queue = []
            i = None
            _len = len(holeIndices)
            start = None
            end = None
            _list = None

            for i in range(len(holeIndices)):
                start = holeIndices[i] * dim
                end =  holeIndices[i + 1] * dim if i < _len - 1 else len(n)
                _list = linkedList(n, start, end, dim, False)

                if (_list == _list.next):
                    _list.steiner = True

                queue.append(getLeftmost(_list))

            queue = sorted(queue, key=lambda i: i.x)

            # process holes from left to right
            for i in range(len(queue)):
                eliminateHole(queue[i], outerNode)
                outerNode = filterPoints(outerNode, outerNode.next)

            return outerNode

        def compareX(a, b):
            return a.x - b.x

        # find a bridge between vertices that connects hole with an outer ring and and link it
        def eliminateHole(hole, outerNode):
            outerNode = findHoleBridge(hole, outerNode)
            if outerNode:
                b = splitPolygon(outerNode, hole)
                filterPoints(b, b.next)

        # David Eberly's algorithm for finding a bridge between hole and outer polygon
        def findHoleBridge(hole, outerNode):
            do = True
            p = outerNode
            hx = hole.x
            hy = hole.y
            qx = -math.inf
            m = None

            # find a segment intersected by a ray from the hole's leftmost point to the left;
            # segment's endpoint with lesser x will be potential connection point
            while do or p != outerNode:
                do = False
                if hy <= p.y and hy >= p.next.y and p.next.y - p.y != 0:
                    x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y)

                    if x <= hx and x > qx:
                        qx = x

                        if (x == hx):
                            if hy == p.y:
                                return p
                            if hy == p.next.y:
                                return p.next

                        m = p if p.x < p.next.x else p.next

                p = p.next

            if not m:
                return None

            if hx == qx:
                return m.prev # hole touches outer segment; pick lower endpoint

            # look for points inside the triangle of hole point, segment intersection and endpoint;
            # if there are no points found, we have a valid connection;
            # otherwise choose the point of the minimum angle with the ray as connection point

            stop = m
            mx = m.x
            my = m.y
            tanMin = math.inf
            tan = None

            p = m.next

            while p != stop:
                hx_or_qx = hx if hy < my else qx
                qx_or_hx = qx if hy < my else hx
                
                if hx >= p.x and p.x >= mx and pointInTriangle(hx_or_qx, hy, mx, my, qx_or_hx, hy, p.x, p.y):

                    tan = abs(hy - p.y) / (hx - p.x) # tangential

                    if (tan < tanMin or (tan == tanMin and p.x > m.x)) and locallyInside(p, hole):
                        m = p
                        tanMin = tan

                p = p.next

            return m

        # interlink polygon nodes in z-order
        def indexCurve(start, minX, minY, size):
            do = True
            p = start

            while do or p != start:
                do = False

                if p.z == None:
                    p.z = zOrder(p.x, p.y, minX, minY, size)

                p.prevZ = p.prev
                p.nextZ = p.next
                p = p.next

            p.prevZ.nextZ = None
            p.prevZ = None

            sortLinked(p)

        # Simon Tatham's linked _list merge sort algorithm
        # http:#www.chiark.greenend.org.uk/~sgtatham/algorithms/_listsort.html
        def sortLinked(_list):
            do = True
            i = None
            p = None
            q = None
            e = None
            tail = None
            numMerges = None
            pSize = None
            qSize = None
            inSize = 1

            while do or numMerges > 1:
                do = False
                p = _list
                _list = None
                tail = None
                numMerges = 0

                while p:
                    numMerges += 1
                    q = p
                    pSize = 0
                    for i in range(inSize):
                        pSize += 1
                        q = q.nextZ
                        if not q:
                            break

                    qSize = inSize

                    while pSize > 0 or (qSize > 0 and q):

                        if pSize == 0:
                            e = q
                            q = q.nextZ
                            qSize -= 1

                        elif (qSize == 0 or not q):
                            e = p
                            p = p.nextZ
                            pSize -= 1

                        elif (p.z <= q.z):
                            e = p
                            p = p.nextZ
                            pSize -= 1

                        else:
                            e = q
                            q = q.nextZ
                            qSize -= 1

                        if tail:
                            tail.nextZ = e

                        else:
                            _list = e

                        e.prevZ = tail
                        tail = e

                    p = q

                tail.nextZ = None
                inSize *= 2

            return _list


        # z-order of a point given coords and size of the data bounding box
        def zOrder(x, y, minX, minY, size):
            # coords are transformed into non-negative 15-bit integer range
            x = 32767 * (x - minX) // size
            y = 32767 * (y - minY) // size

            x = (x | (x << 8)) & 0x00FF00FF
            x = (x | (x << 4)) & 0x0F0F0F0F
            x = (x | (x << 2)) & 0x33333333
            x = (x | (x << 1)) & 0x55555555

            y = (y | (y << 8)) & 0x00FF00FF
            y = (y | (y << 4)) & 0x0F0F0F0F
            y = (y | (y << 2)) & 0x33333333
            y = (y | (y << 1)) & 0x55555555

            return x | (y << 1)

        # find the leftmost node of a polygon ring
        def getLeftmost(start):
            do = True
            p = start
            leftmost = start

            while do or p != start:
                do = False
                if p.x < leftmost.x:
                    leftmost = p
                p = p.next

            return leftmost

        # check if a point lies within a convex triangle
        def pointInTriangle(ax, ay, bx, by, cx, cy, px, py):
            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 and \
                (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 and \
                (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0

        # check if a diagonal between two polygon nodes is valid (lies in polygon interior)
        def isValidDiagonal(a, b):
            return a.next.i != b.i and a.prev.i != b.i and not intersectsPolygon(a, b) and \
                locallyInside(a, b) and locallyInside(b, a) and middleInside(a, b)

        # signed area of a triangle
        def area(p, q, r):
            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)

        # check if two points are equal
        def equals(p1, p2):
            return p1.x == p2.x and p1.y == p2.y


        # check if two segments intersect
        def intersects(p1, q1, p2, q2):
            if (equals(p1, q1) and equals(p2, q2)) or (equals(p1, q2) and equals(p2, q1)):
                return True

            return area(p1, q1, p2) > 0 != area(p1, q1, q2) > 0 and \
                area(p2, q2, p1) > 0 != area(p2, q2, q1) > 0

        # check if a polygon diagonal intersects any polygon segments
        def intersectsPolygon(a, b):
            do = True
            p = a

            while do or p != a:
                do = False
                if (p.i != a.i and p.next.i != a.i and p.i != b.i and p.next.i != b.i and intersects(p, p.next, a, b)):
                    return True

                p = p.next

            return False

        # check if a polygon diagonal is locally inside the polygon
        def locallyInside(a, b):
            if area(a.prev, a, a.next) < 0:
                return  area(a, b, a.next) >= 0 and area(a, a.prev, b) >= 0
            else:
                return area(a, b, a.prev) < 0 or area(a, a.next, b) < 0

        # check if the middle point of a polygon diagonal is inside the polygon
        def middleInside(a, b):
            do = True
            p = a
            inside = False
            px = (a.x + b.x) / 2
            py = (a.y + b.y) / 2

            while do or p != a:
                do = False
                if ((p.y > py) != (p.next.y > py)) and (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x):
                    inside = not inside

                p = p.next

            return inside

        # link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
        # if one belongs to the outer ring and another to a hole, it merges it into a single ring
        def splitPolygon(a, b):
            a2 = Node(a.i, a.x, a.y)
            b2 = Node(b.i, b.x, b.y)
            an = a.next
            bp = b.prev

            a.next = b
            b.prev = a

            a2.next = an
            an.prev = a2

            b2.next = a2
            a2.prev = b2

            bp.next = b2
            b2.prev = bp

            return b2


        # create a node and optionally link it with previous one (in a circular doubly linked _list)
        def insertNode(i, x, y, last):
            p = Node(i, x, y)

            if not last:
                p.prev = p
                p.next = p

            else:
                p.next = last.next
                p.prev = last
                last.next.prev = p
                last.next = p

            return p

        def removeNode(p):
            p.next.prev = p.prev
            p.prev.next = p.next

            if p.prevZ:
                p.prevZ.nextZ = p.nextZ

            if p.nextZ:
                p.nextZ.prevZ = p.prevZ

        class Node(object):
            def __init__(self, i, x, y):
            # vertice index in coordinates array
                self.i = i

                # vertex coordinates
                self.x = x
                self.y = y

                # previous and next vertice nodes in a polygon ring
                self.prev = None
                self.next = None

                # z-order curve value
                self.z = None

                # previous and next nodes in z-order
                self.prevZ = None
                self.nextZ = None

                # indicates whether this is a steiner point
                self.steiner = False


        # return a percentage difference between the polygon area and its triangulation area;
        # used to verify correctness of triangulation
        def deviation(n, holeIndices, dim, triangles):
            _len = len(holeIndices)
            hasHoles = holeIndices and len(holeIndices)
            outerLen = holeIndices[0] * dim if hasHoles else len(n)

            polygonArea = abs(signedArea(n, 0, outerLen, dim))

            if hasHoles:
                for i in range(_len):
                    start = holeIndices[i] * dim
                    end = holeIndices[i + 1] * dim if i < _len - 1 else len(n)
                    polygonArea -= abs(signedArea(n, start, end, dim))

            trianglesArea = 0

            for i in range(0, len(triangles), 3):
                a = triangles[i] * dim
                b = triangles[i + 1] * dim
                c = triangles[i + 2] * dim
                trianglesArea += abs(
                    (n[a] - n[c]) * (n[b + 1] - n[a + 1]) -
                    (n[a] - n[b]) * (n[c + 1] - n[a + 1]))

            if polygonArea == 0 and trianglesArea == 0:
                return 0

            return abs((trianglesArea - polygonArea) / polygonArea)


        def signedArea(n, start, end, dim):
            sum = 0
            j = end - dim

            for i in range(start, end, dim):
                sum += (n[j] - n[i]) * (n[i + 1] + n[j + 1])
                j = i

            return sum


        # turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
        def flatten(n):
            dim = len(n[0][0])
            result = {
                'vertices': [],
                'holes': [],
                'dimensions': dim
            }
            holeIndex = 0

            for i in range(len(n)):
                for j in range(len(n[i])):
                    for d in range(dim):
                        result['vertices'].append(n[i][j][d])

                if i > 0:
                    holeIndex += len(n[i - 1])
                    result['holes'].append(holeIndex)

            return result

        def unflatten(n):
            result = []

            for i in range(0, len(n), 3):
                result.append(tuple(n[i:i + 3]))

            return result


        #Clear None
        not_none_values = filter(None.__ne__, P)
        P = list(not_none_values)
        P = np.array(P)
        print(P)

        #Save file
        np.savetxt(output_file_EarClip, P, delimiter='  ', fmt='%f') #save file
        self.iface.messageBar().pushMessage("Success", "Output file written at " + filenameOutEarClip, level=Qgis.Success, duration=3)

        #Plot data
        fig = plt.figure()
        ax = fig.add_subplot(111)

        plt.ylim(-5, 15)
        plt.xlim(-5, 15)

        plt.plot(ECAI)
        plt.axis('on')
        plt.title('Ear-Clip-Algorithm')
        plt.show()

    # ------------- Laserpoints  ------------- #
    def import_laserpoints(self):
        """Laserponts import function"""
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select file","", '*.las')
        self.dlg.LaserDataImportPath.setText(filename)

    def export_laserpoints(self):
        """Laserpoints export function"""
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select output file ","", '*.las *.txt')
        self.dlg.LaserDataExportPath.setText(filename)

    def execute_laserpoints(self):
        """Main function laserpoints"""
        filenameInLaserPoly = self.dlg.LaserDataImportPath.text() # Filename Input Points
        filenameOutLaser = self.dlg.LaserDataExportPath.text() # Filename Output

        # Read file
        laserPoly = File(filenameInLaserPoly, mode='r')

        # https://stackoverflow.com/questions/44766591/vispy-two-data-sets-on-same-plot-with-colors
        # build your visuals, that's all
        Scatter3D = scene.visuals.create_visual_node(visuals.MarkersVisual)

        # Vispy
        canvas = scene.SceneCanvas(keys='interactive', show=True)

        # Add a ViewBox to let the user zoom/rotate
        view = canvas.central_widget.add_view()
        view.camera = 'turntable'
        view.camera.fov = 45
        view.camera.distance = 1000000

        # create Points for plot
        laserPolyPos = [] # empty structure
        laserPolyPos = [laserPoly.X, laserPoly.Y, laserPoly.Z] # Point coordinates
        laserPolyPos = np.array(laserPolyPos).T # Transponate into the right form

        laserPolyX = [laserPoly.X] # X
        laserPolyX = np.array(laserPolyX)
        laserPolyY = [laserPoly.Y] # Y
        laserPolyY = np.array(laserPolyY)
        laserPolyZ = [laserPoly.Z] # Z
        laserPolyZ = np.array(laserPolyZ)

        laserPolyClass = [laserPoly.Classification] # Classification
        laserPolyClass = np.array(laserPolyClass)

        laserPolyIntensity = [laserPoly.Intensity] # Intensity
        laserPolyIntensity = np.array(laserPolyIntensity)

        n = len(laserPoly.X)
        laserPolyData = np.zeros(n, [('a_x', np.float32, 1),
                         ('a_y', np.float32, 1),
                         ('a_z', np.float32, 1),
                         ('a_classification', np.float32, 1),
                         ('a_intensity', np.float32, 1)])
        laserPolyData['a_x'] = laserPolyX
        laserPolyData['a_y'] = laserPolyY
        laserPolyData['a_z'] = laserPolyZ
        laserPolyData['a_classification'] = laserPolyClass
        laserPolyData['a_intensity'] = laserPolyIntensity

        # Output file
        np.savetxt(filenameOutLaser, laserPolyData, fmt='%s') #save File

        color = np.array([[1, 0.4, 0]] * n) # orange

        # Set camera center
        half = int(len(laserPoly.X) / 2)
        view.camera.center = (laserPolyPos[half,0],laserPolyPos[half,1],laserPolyPos[half,2])
        
        # plot ! note the parent parameter
        p1 = Scatter3D(parent=view.scene)
        p1.set_gl_state('translucent', blend=True, depth_test=True)
        p1.set_data(laserPolyPos, face_color=color, symbol='o', size=1.5, edge_width=0.1, edge_color='blue')
        view.add(p1)
        canvas.app.run()
        # Processing status in QGIS
        self.iface.messageBar().pushMessage("Success", "Output file written at " + filenameOutLaser, level=Qgis.Success, duration=3)

    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GisProgrammierungCSFTFFDialog()
            # ------------- Convex Hull ------------- #
            self.dlg.ConvexHullImport.clicked.connect(self.import_points_convexHull) # Convex Hull Import Button
            self.dlg.ConvexHullExport.clicked.connect(self.export_points_convexHull) # Convex Hull Import Button
            self.dlg.generateConvexHull.clicked.connect(self.execute_convexHull) # Triggers Convex Hull algorithm

            # ------------- Point in Polygon ------------- #
            self.dlg.PointsImportPIP.clicked.connect(self.import_points_PIP) # Point in Polygon Import Point Button
            self.dlg.PolygonImportPIP.clicked.connect(self.import_polygon_PIP) # Point in Polygon Import Polygon Button
            self.dlg.ExportPIP.clicked.connect(self.export_PIP) # Point in Polygon Export Button
            self.dlg.generatePIP.clicked.connect(self.execute_pip) # Triggers Convex Hull algorithm

            # ------------- Ear-Clipping-Algorithm ------------- #
            self.dlg.EarClippingImport.clicked.connect(self.import_poly_ear) # Ear-Clipping-Algorithm Import Polygon Button
            self.dlg.EarClippingExport.clicked.connect(self.export_ear) # Ear-Clipping-Algorithm Export Button
            self.dlg.generateEarClipping.clicked.connect(self.execute_ear) # Triggers Ear-Clipping-Algorithm

            # ------------- Laserpoints ------------- #
            self.dlg.LaserDataImport.clicked.connect(self.import_laserpoints) # Laserpoints import button
            self.dlg.LaserDataExport.clicked.connect(self.export_laserpoints) # Laserpoints export button
            self.dlg.gernateLaserData.clicked.connect(self.execute_laserpoints) # Triggers laserpoints main function

            # ------------- Close Button ------------- #
            self.dlg.closeConvexHull.clicked.connect(self.close_function) # close UI
            self.dlg.closePIP.clicked.connect(self.close_function) # close UI
            self.dlg.closeEarClipping.clicked.connect(self.close_function) # close UI
            self.dlg.closeLaserData.clicked.connect(self.close_function) # close UI
            self.dlg.closeDTM.clicked.connect(self.close_function) # close UI

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            
            pass
