# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GisProgrammierungCSFTFF
                                 A QGIS plugin
 Das Plugin analysiert DGMs und reale Punktwolken auf folgende geometrischen Alogrithmen: "Konvexe Hülle", 
 "Punkt-in-Polygon-Test" und dem "Ear-Clipping-Algorithmus". Die Ergebnisse werden visualisert und einem Performancevergleich (m/s) unterzogen. 
 Hierbei wird eine große Anzahl von Geoobjekten (> 1.000.000) in eine relationale und Objektdatenbank gespeichert und eingelesen. 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-01-04
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Czarnach Simone, Feicht Tamara, Folger Florian
        email                : czarnach@hm.edu, Klein6@hm.edu, ffolger@hm.edu
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import QgsProject, Qgis

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .gis_programmierung_cs_ft_ff_dialog import GisProgrammierungCSFTFFDialog
import os.path
# Import for Ear-Clipping
import scipy
from scipy.spatial import Delaunay
# Import vispy, laspy and numpy
import vispy
from vispy import app, gloo, visuals, scene
import laspy
from laspy.file import File
import matplotlib.pyplot as plt
import persistent
import transaction
import ZODB 
from ZODB import FileStorage, DB
import time
from datetime import datetime
from timeit import default_timer as timer
import sqlite3
import numpy as np

class GisProgrammierungCSFTFF:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GisProgrammierungCSFTFF_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GIS-Programmierung CS FT FF')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.
        We implement this ourselves since we do not inherit QObject.
        :param message: String for translation.
        :type message: str, QString
        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GisProgrammierungCSFTFF', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.
        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str
        :param text: Text that should be shown in menu items for this action.
        :type text: str
        :param callback: Function to be called when the action is triggered.
        :type callback: function
        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool
        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool
        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool
        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str
        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget
        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.
        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/gis_programmierung_cs_ft_ff/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Gis-Programmierung Plugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&GIS-Programmierung CS FT FF'),
                action)
            self.iface.removeToolBarIcon(action)

    def close_function(self):
        """Closing function"""
        self.dlg.close()

    # ------------- Convex Hull ------------- #
    def import_points_convexHull(self):
        """Convex Hull Import function"""
        filename, _filter = QFileDialog.getOpenFileName( self.dlg, 'Select input file ','', '*.shp *.txt *.csv *.ply')
        self.dlg.ConvexHullImportPath.setText(filename) 
    
    def export_points_convexHull(self):
        """Convex Hull Export function"""
        filename, _filter = QFileDialog.getSaveFileName( self.dlg, 'Select output file ','', '*shp *.csv *.txt *.ply')
        self.dlg.ConvexHullExportPath.setText(filename)

    def execute_convexHull(self):
        """Main Convex Hull function, lesson 3"""
        filenameInConvHull = self.dlg.ConvexHullImportPath.text() # Filename Input
        filenameOutConvHull = self.dlg.ConvexHullExportPath.text() # Filename Output
        output_file_convHull = open(filenameOutConvHull, 'w')
        # Read file
        with open(filenameInConvHull, 'r') as file:
            S = np.genfromtxt(file, dtype=None)

        n = len(S)
        P = [None] * n
        l = np.where(S[:,0] == np.min(S[:,0]))
        pointOnHull = S[l[0][0]]

        def CCW(p1, p2, p3):
            """Function to know if we have a CCW turn (counter-clockwise)"""
            if (p3[1]-p1[1])*(p2[0]-p1[0]) >= (p2[1]-p1[1])*(p3[0]-p1[0]):
                return True
            return False

        i = 0
        while True:
            P[i] = pointOnHull
            endpoint = S[0]
            for j in range(1,n):
                if (endpoint[0] == pointOnHull[0] and endpoint[1] == pointOnHull[1]) or not CCW(S[j],P[i],endpoint):
                    endpoint = S[j]
            i = i + 1
            pointOnHull = endpoint
            if endpoint[0] == P[0][0] and endpoint[1] == P[0][1]:
                break

        for i in range(n):
            if P[-1] is None:
                del P[-1]
        P = np.array(P)
        np.savetxt(output_file_convHull, np.array(P), delimiter=' ', fmt='%f') #save File
        # Processing status in QGIS
        self.iface.messageBar().pushMessage("Success", "Output file written at " + filenameOutConvHull, level=Qgis.Success, duration=3)
        
        fig = plt.figure()
        ax = fig.add_subplot(111)  # vgl. https://matplotlib.org/api/_as_gen/matplotlib.pyplot.subplot.html (10.12.2018)
        # vgl. https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.set_ylim.html

        # plot axis
        minAxis = np.amin(P)
        maxAxis = np.amax(P)
        if minAxis <= 0:
            plt.ylim(minAxis - 2, maxAxis + 2)
            plt.xlim(minAxis - 2, maxAxis + 2)
        else:
            plt.ylim(minAxis + 2, maxAxis + 2)
            plt.xlim(minAxis + 2, maxAxis + 2)

        # vgl. https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html  
        plt.plot(P[:,0],P[:,1], 'b-')  # b = blau
        plt.plot([P[-1,0],P[0,0]],[P[-1,1],P[0,1]], 'b-')
        # Punkte in Hülle: rot
        plt.plot(S[:,0],S[:,1],"r^")
        # Punkte auf Hülle: grün + square marker
        plt.plot(P[:,0],P[:,1],"gs", markersize=7)
        # Koordinaten anzeigen
        for xy in zip(P[:,0],P[:,1]):                                                           
            ax.annotate('%s, %s' %xy, xy=xy, textcoords='data', ha='center', va='bottom', fontstyle='normal')   
        plt.axis('on')
        plt.title('Berechnung einer konvexen Hülle')
        plt.show()

    # ------------- Point in Polygon ------------- #
    def import_polygon_PIP(self):
        """Point in Polygon Import Polygon-function"""
        filename, _filter = QFileDialog.getOpenFileName( self.dlg, 'Select input file ','', '*shp *.csv *.txt *.ply')
        self.dlg.PolygonPIPImportPath.setText(filename)
        
    def import_points_PIP(self):
        """Point in Polygon Import Point-function"""
        filename, _filter = QFileDialog.getOpenFileName( self.dlg, 'Select input file ','', '*shp *.csv *.txt *.ply')
        self.dlg.PointPIPImportPath.setText(filename)

    def export_PIP(self):
        """Point in Poly Export function"""
        filename, _filter = QFileDialog.getSaveFileName( self.dlg, 'Select output file ','', '*shp *.csv *.txt *.ply')
        self.dlg.PIPExportPath.setText(filename)
    
    def execute_pip(self):
        """Main Point in Polygon function, lesson 2"""
        filenameInPIPPoints = self.dlg.PointPIPImportPath.text() # Filename Input Points
        filenameInPIPPoly = self.dlg.PolygonPIPImportPath.text() # Filename Input Polygon
        filenameOutPIP = self.dlg.PIPExportPath.text() # Filename Output

        output_file_PIP = open(filenameOutPIP, 'w')
        # Read file
        with open(filenameInPIPPoints, 'r') as file:
            pipPoints = np.genfromtxt(file, dtype=None) # pipPoints[0] = x, pipPoints[1] = y

        with open(filenameInPIPPoly, 'r') as file:
            pipPoly = np.genfromtxt(file, dtype=None, encoding='utf-8')
    
        print(pipPoints)
        n = len(pipPoly)
        N = len(pipPoints)
        P = [None] * N

        p1x,p1y = pipPoly[0]
        for i in range(n+1):
            p2x,p2y = pipPoly[i % n]
            for j in range(N):
                if pipPoints[j][1] > min(p1y,p2y):
                    if pipPoints[j][1] <= max(p1y,p2y):
                        if pipPoints[j][0] <= max(p1x,p2x):
                            if p1y != p2y:
                                xints = (pipPoints[j][1]-p1y)*(p2x-p1x)/(p2y-p1y)+p1x
                            if p1x == p2x or pipPoints[j][0] <= xints:
                                P[j] = (pipPoints[j][0], pipPoints[j][1])        
            p1x,p1y = p2x,p2y
        # Clear None
        Not_none_values = filter(None.__ne__, P)
        P = list(Not_none_values)
        P = np.array(P)

        # Save file
        np.savetxt(output_file_PIP, P, delimiter=' ', fmt='%f') #save File
        # Processing status in QGIS
        self.iface.messageBar().pushMessage("Success", "Output file written at " + filenameOutPIP, level=Qgis.Success, duration=3)
    
        # Plot data
        fig = plt.figure()
        ax = fig.add_subplot(111)  # vgl. https://matplotlib.org/api/_as_gen/matplotlib.pyplot.subplot.html (10.12.2018)
        # vgl. https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.set_ylim.html

        # plot axis
        minAxis = np.amin(pipPoly)
        maxAxis = np.amax(pipPoly)
        if minAxis <= 0:
            plt.ylim(minAxis - 2, maxAxis + 2)
            plt.xlim(minAxis - 2, maxAxis + 2)
        else:
            plt.ylim(minAxis + 2, maxAxis + 2)
            plt.xlim(minAxis + 2, maxAxis + 2)

        # vgl. https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html  
        plt.plot(pipPoly[:,0],pipPoly[:,1], 'b-')  # b = blau
        plt.plot([pipPoly[-1,0],pipPoly[0,0]],[pipPoly[-1,1],pipPoly[0,1]], 'b-')
        # Punkte in Hülle: rot
        plt.plot(P[:,0], P[:,1],"rx")
        # Koordinaten anzeigen
        for xy in zip(pipPoly[:,0],pipPoly[:,1]):                                                           
            ax.annotate('%s, %s' %xy, xy=xy, textcoords='data', ha='center', va='bottom', fontstyle='normal')     
        plt.axis('on')
        plt.title('Points in Polygon')
        plt.show()

    # ------------- Ear-Clipping-Algorithm  ------------- #
    def import_poly_ear(self):
        """Ear-Clipping-Algorithm import Polygon-function"""
        filename, _filter = QFileDialog.getOpenFileName( self.dlg, 'Select input file ','', '*shp *.csv *.txt *.ply')
        self.dlg.PolygonECAImportPath.setText(filename)

    def export_ear(self):
        """Ear-Clipping-Algorithm export Polygon-function"""
        filename, _filter = QFileDialog.getSaveFileName( self.dlg, 'Select output file ','', '*.ply *.txt')
        self.dlg.EarClippingExportPath.setText(filename)

    def execute_ear(self):
        """Execute Ear-Clipping-Algorithm"""       
        filenameInEarClip = self.dlg.PolygonECAImportPath.text() # Filename Input Polygon
        filenameOutEarClip = self.dlg.EarClippingExportPath.text() # Filename Output

        output_file_EarClip = open(filenameOutEarClip, 'w')
        # Read file
        with open(filenameInEarClip, 'r') as file:
            ECAI = np.genfromtxt(file, dtype=None, encoding='utf-8')

        print(ECAI)
        n = len(ECAI)
        P = [None] * n
            
        #Take Delaunayfunction 
        tri = Delaunay(ECAI)

        #Clear None
        not_none_values = filter(None.__ne__, P)
        P = list(not_none_values)
        P = np.array(P)
        print(P)

        #Save file
        np.savetxt(output_file_EarClip, P, delimiter='  ', fmt='%f') #save file
        # Processing status in QGIS
        self.iface.messageBar().pushMessage("Success", "Output file written at " + filenameOutEarClip, level=Qgis.Success, duration=3)

        #Plot data
        fig = plt.figure()
        ax = fig.add_subplot(111)

        minAxis = np.amin(ECAI)
        maxAxis = np.amax(ECAI)
        if minAxis <= 0:
            plt.ylim(minAxis - 2, maxAxis + 2)
            plt.xlim(minAxis - 2, maxAxis + 2)
        else:
            plt.ylim(minAxis, maxAxis)
            plt.xlim(minAxis, maxAxis)

        plt.triplot(ECAI[:,0], ECAI[:,1], tri.simplices)
        plt.plot(ECAI[:,0], ECAI[:,1], 'rx')
        
        # Koordinaten anzeigen
        for xy in zip(ECAI[:,0],ECAI[:,1]):                                                           
            ax.annotate('%s, %s' %xy, xy=xy, textcoords='data', ha='center', va='bottom', fontstyle='normal')   
        plt.axis('on')
        plt.title('Ear-Clip-Algorithm')
        plt.show()

    # ------------- Laserpoints  ------------- #
    def import_laserpoints(self):
        """Laserpoints import function"""
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select file","", '*.las')
        self.dlg.LaserDataImportPath.setText(filename)

    def export_laserpoints(self):
        """Laserpoints export function"""
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select output file ","", '*.las *.txt')
        self.dlg.LaserDataExportPath.setText(filename)

    def execute_laserpoints(self):
        """Main function laserpoints"""
        filenameInLaserPoly = self.dlg.LaserDataImportPath.text() # Filename Input Points
        filenameOutLaser = self.dlg.LaserDataExportPath.text() # Filename Output

        # Read file
        laserPoly = File(filenameInLaserPoly, mode='r')

        # https://stackoverflow.com/questions/44766591/vispy-two-data-sets-on-same-plot-with-colors
        # build your visuals, that's all
        Scatter3D = scene.visuals.create_visual_node(visuals.MarkersVisual)

        # Vispy
        canvas = scene.SceneCanvas(keys='interactive', show=True)

        # Add a ViewBox to let the user zoom/rotate
        view = canvas.central_widget.add_view()
        view.camera = 'turntable'
        view.camera.fov = 45
        view.camera.distance = 1000000

        # create Points for plot
        laserPolyPos = [] # empty structure
        laserPolyPos = [laserPoly.X, laserPoly.Y, laserPoly.Z] # Point coordinates
        laserPolyPos = np.array(laserPolyPos).T # Transponate into the right form

        laserPolyX = [laserPoly.X] # X
        laserPolyX = np.array(laserPolyX)
        laserPolyY = [laserPoly.Y] # Y
        laserPolyY = np.array(laserPolyY)
        laserPolyZ = [laserPoly.Z] # Z
        laserPolyZ = np.array(laserPolyZ)

        laserPolyClass = [laserPoly.Classification] # Classification
        laserPolyClass = np.array(laserPolyClass)

        laserPolyIntensity = [laserPoly.Intensity] # Intensity
        laserPolyIntensity = np.array(laserPolyIntensity)

        n = len(laserPoly.X)
        laserPolyData = np.zeros(n, [('a_x', np.float32, 1),
                         ('a_y', np.float32, 1),
                         ('a_z', np.float32, 1),
                         ('a_classification', np.float32, 1),
                         ('a_intensity', np.float32, 1)])
        laserPolyData['a_x'] = laserPolyX
        laserPolyData['a_y'] = laserPolyY
        laserPolyData['a_z'] = laserPolyZ
        laserPolyData['a_classification'] = laserPolyClass
        laserPolyData['a_intensity'] = laserPolyIntensity

        # Output file
        np.savetxt(filenameOutLaser, laserPolyData, fmt='%s') #save File
        # Processing status in QGIS
        self.iface.messageBar().pushMessage("Success", "Output file written at " + filenameOutLaser, level=Qgis.Success, duration=3)

        color = np.array([[1, 0.4, 0]] * n) # orange

        # Set camera center
        half = int(len(laserPoly.X) / 2)
        view.camera.center = (laserPolyPos[half,0],laserPolyPos[half,1],laserPolyPos[half,2])
        
        # plot ! note the parent parameter
        p1 = Scatter3D(parent=view.scene)
        p1.set_gl_state('translucent', blend=True, depth_test=True)
        p1.set_data(laserPolyPos, face_color=color, symbol='o', size=1.5, edge_width=0.1, edge_color='blue')
        view.add(p1)
        canvas.app.run()

    # ------------- Geländemodell  ------------- #
    def import_dtm(self):
        """DTM import function"""
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select file","", '*.txt')
        self.dlg.DTMImportPath.setText(filename)

    def execute_dtm(self):
        """Main function DTM"""
        filenameInDTM = self.dlg.DTMImportPath.text() # Filename Input DTM

        # Read file
        with open(filenameInDTM, 'r') as file:
            dataDTM = np.loadtxt(filenameInDTM)

        # https://stackoverflow.com/questions/44766591/vispy-two-data-sets-on-same-plot-with-colors
        # https://stackoverflow.com/questions/62259090/vispy-turntable-camera-roll-option-not-working
        # build your visuals, that's all
        Scatter3D = scene.visuals.create_visual_node(visuals.MarkersVisual)

        # The real-things : plot using scene
        # build canvas
        canvas = scene.SceneCanvas(keys='interactive', show=True)

        # Add a ViewBox to let the user zoom/rotate
        view = canvas.central_widget.add_view()
        view.camera = 'turntable'
        view.camera.fov = 45
        view.camera.distance = 3000

        # Output file
        n = len(dataDTM)
        #np.savetxt(filenameOutDTM, dtmStack, fmt='%s') #save File
        color = np.array([[1, 0.4, 0]] * n) # orange

        # Set camera center
        half = int(len(dataDTM) / 2)
        view.camera.center = (dataDTM[half,0],dataDTM[half,1],dataDTM[half,2])

        # Processing status in QGIS
        self.iface.messageBar().pushMessage("Success", "Input file read " + filenameInDTM, level=Qgis.Success, duration=3)

        # plot ! note the parent parameter
        p1 = Scatter3D(parent=view.scene)
        p1.set_gl_state('translucent', blend=True, depth_test=True)
        p1.set_data(np.array(dataDTM), face_color=color, symbol='o', size=1.5, edge_width=0.1, edge_color='orange')
        view.add(p1)
        canvas.app.run()
            
            
    # ------------- DB Performance  ------------- #
    def export_ZODB(self):
        """ZODB export function"""
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select output file ","", '*.fs')
        self.dlg.ExportPathZODB.setText(filename)

    def export_SQLite3(self):
        """OODB export function"""
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select output file ","", '*.gpgk')
        self.dlg.ExportPathSQLite3.setText(filename)

    def execute_ZODB(self):
        """ main function object database ZODB"""
        filenameOutZODB = self.dlg.ExportPathZODB.text() # Filename Output
        storage = FileStorage.FileStorage(filenameOutZODB)
        db = DB(storage)
    
        # generate geopoints
        n = int(self.dlg.NumberOfGeoobjects.text())
        nStr = self.dlg.NumberOfGeoobjects.text()
        zodbPoints = np.random.rand(n, 2) * 100

        # open connection, start timer
        connection = db.open()
        root = connection.root()
        
        # start timer
        startTimer = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]

        start = timer()
        fullstart = start
    
        root['points'] = []
        dbPoints = root['points']
        for i in range(len(zodbPoints)):
            dbPoints.append((zodbPoints[i,0], zodbPoints[i,1]))
        root['points'] = dbPoints
        transaction.commit()

        # datestring with timestamp
        endTimer = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]

        # end timer
        end = timer()
        # print time
        self.dlg.ZODBPerfOutput.setText("Total time : %.1f ms" % (1000 * (end - fullstart)) + "\n\r")
        self.dlg.ZODBPerfOutput.setText("Geoobjects used: " + nStr + "\n\r" +
                                        "Start time: " + startTimer + "\n\r" +
                                        "End time: " + endTimer + "\n\r" +
                                        "Total time : %.1f ms" % (1000 * (end - fullstart)) + "\n\r")

        # Processing status in QGIS
        self.iface.messageBar().pushMessage("Success", "Output file written at " + filenameOutZODB, level=Qgis.Success, duration=3)
        
        connection.close()

    def execute_SQLite3(self):
        """ main function object database ZODB"""
        # create new db file
        filenameOutOODB = self.dlg.ExportPathSQLite3.text() # Filename Output
        verbindungsaufbau = sqlite3.connect(filenameOutOODB)
        dbzugriff = verbindungsaufbau.cursor()

        # create table points
        dbzugriff.execute("CREATE TABLE IF NOT EXISTS 'points' ( \
            x REAL, \
            y REAL)"
        )

        # generate geopoints
        n = int(self.dlg.NumberOfGeoobjects.text())
        nStr = self.dlg.NumberOfGeoobjects.text()
        oodbPoints = np.random.rand(n, 2) * 100
    
        # start timer
        startTimer = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]

        start = timer()
        fullstart = start

        for i in range(n):
            dbzugriff.execute("INSERT INTO 'points' ('x', 'y') VALUES(?, ?)", (oodbPoints[i,0], oodbPoints[i,1]))
            verbindungsaufbau.commit()
    
        # datestring with timestamp
        endTimer = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        

        # end timer
        end = timer()
        # print time
        self.dlg.SQLite3PerfOutput.setText("Geoobjects used: " + nStr + "\n\r" +
                                        "Start time: " + startTimer + "\n\r" +
                                        "End time: " + endTimer + "\n\r" +
                                        "Total time : %.1f ms" % (1000 * (end - fullstart)) + "\n\r")

        dbzugriff.close()

        # Processing status in QGIS
        self.iface.messageBar().pushMessage("Success", "Output file written at " + filenameOutOODB, level=Qgis.Success, duration=3)
    # ------------- Geländemodell  ------------- #
    def import_dtm(self):
        """Laserponts import function"""
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select file","", '*.las')
        self.dlg.DTMImportPath.setText(filename)

    def export_dtm(self):
        """Laserpoints export function"""
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select output file ","", '*.las *.txt')
        self.dlg.DTMExportPath.setText(filename)

    def execute_dtm(self):
        """Main function laserpoints"""
        filenameInDTM = self.dlg.LaserDataImportPath.text() # Filename Input Points
        filenameOutLaser = self.dlg.LaserDataExportPath.text() # Filename Output

        # Read file
        datafile = File(filenameInDTM, mode='r')

        def generatePcl(points_array):
            point_cloud = pcl.PointCloud(points_array)
            # Transform and create pcd file
            fil = point_cloud.make_statistical_outlier_filter()
            fil.set_mean_k(50)
            fil.set_std_dev_mul_thresh(0.3)
            
            fil.set_negative(False)
            # Inlier
            pcl.save(fil.filter(), pcdInlierfile)

            # Outlier
            fil.set_negative(True)
            pcl.save(fil.filter(), pcdOutlierfile)
            

            return 0

        # Functions used to read and convert data into float and arrays.

        # Read the fuse file line after line
        def processFile(filename):
            fullArray = []
            with open(filename) as f:
                if (os.path.splitext(filename)[1]) == ".pcd":
                    for _ in xrange(11):
                        next(f)
                
                if (os.path.splitext(filename)[1]) == ".pcd":    
                    for line in f:
                        lat, lon, elev = line.strip().split(" ")
                        lineArray = [float(lat), float(lon), float(elev)]
                        fullArray.append(lineArray)
                    
                for line in f:
                    lat, lon, elev, intensity = line.strip().split(" ")
                    lineArray = [float(lat), float(lon), float(elev)]
                    fullArray.append(lineArray)    
                    
                return fullArray


        # Select a column from a multidimensional array
        def column(matrix, i):
            return [row[i] for row in matrix]


        def generatePlot(array, minimum, maximum):
            x = np.array(column(array, 0))
            y = np.array(column(array, 1))
            z = np.array(column(array, 2))

            print("bounding values: %s,%s,%s,%s" %(min(x), min(y), max(x), max(y)))

            colors = define_color(z, minimum, maximum)

            fig = figure(plot_width = plot_width, plot_height = plot_height)
            fig.scatter(x, y, fill_alpha=0.6, color=colors, line_color=None)
            
            return fig


        def renderPlot(s1, s2, s3):
            p = gridplot(([[s1, s2, s3]]))
            output_file("\\DTM_Scatter.html", title="Digital Terrain Model")
            print("Opening Browser")
            show(p)  # open a browser
            return 0


        def define_color(z, minimum, maximum):
            colors = []

            h = (0.8 - (i - minimum) * 0.8 / (maximum - minimum) for i in z)
            i = 0
            for j in h:
                c = colorsys.hsv_to_rgb(j, 1, 1)
                c_rgb = "#%02x%02x%02x" % (c[0] * 255, c[1] * 255, c[2] * 255)
                colors.append(c_rgb)
                i += 1
            return colors


        def main():

            array = processFile(datafile)   # Read data file
            
            # Set variables minimum and maximum to keep the same color scale.
            minimum = min(np.array(column(array, 2)))
            maximum = max(np.array(column(array, 2)))                       
                               
            s1 = generatePlot(array, minimum, maximum)

            generatePcl(array)              # Generate pcl file
            
            pclOutarray = processFile(pcdOutlierfile) # Read outlier pcl file
            s2 = generatePlot(pclOutarray, minimum, maximum)
            
            pclInarray = processFile(pcdInlierfile) # Read inlier pcl file
            s3 = generatePlot(pclInarray, minimum, maximum)
            
            renderPlot(s1, s2, s3)

        if __name__ == '__main__':
            main()


    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GisProgrammierungCSFTFFDialog()
            # ------------- Convex Hull ------------- #
            self.dlg.ConvexHullImport.clicked.connect(self.import_points_convexHull) # Convex Hull Import Button
            self.dlg.ConvexHullExport.clicked.connect(self.export_points_convexHull) # Convex Hull Import Button
            self.dlg.generateConvexHull.clicked.connect(self.execute_convexHull) # Triggers Convex Hull algorithm

            # ------------- Point in Polygon ------------- #
            self.dlg.PointsImportPIP.clicked.connect(self.import_points_PIP) # Point in Polygon Import Point Button
            self.dlg.PolygonImportPIP.clicked.connect(self.import_polygon_PIP) # Point in Polygon Import Polygon Button
            self.dlg.ExportPIP.clicked.connect(self.export_PIP) # Point in Polygon Export Button
            self.dlg.generatePIP.clicked.connect(self.execute_pip) # Triggers Convex Hull algorithm

            # ------------- Ear-Clipping-Algorithm ------------- #
            self.dlg.EarClippingImport.clicked.connect(self.import_poly_ear) # Ear-Clipping-Algorithm Import Polygon Button
            self.dlg.EarClippingExport.clicked.connect(self.export_ear) # Ear-Clipping-Algorithm Export Button
            self.dlg.generateEarClipping.clicked.connect(self.execute_ear) # Triggers Ear-Clipping-Algorithm

            # ------------- Laserpoints ------------- #
            self.dlg.LaserDataImport.clicked.connect(self.import_laserpoints) # Laserpoints import button
            self.dlg.LaserDataExport.clicked.connect(self.export_laserpoints) # Laserpoints export button
            self.dlg.gernateLaserData.clicked.connect(self.execute_laserpoints) # Triggers laserpoints main function

            # ------------- DTM ------------- #
            self.dlg.DTMImport.clicked.connect(self.import_dtm) # DTM import button
            self.dlg.generateDTM.clicked.connect(self.execute_dtm) # Triggers DTM main function
            
            # ------------- DB Performance ------------- #
            self.dlg.ExportZODB.clicked.connect(self.export_ZODB) # ZODB export button
            self.dlg.ExportSQLite3.clicked.connect(self.export_SQLite3) # OODB export button
            self.dlg.gernateDBPerformanceZODB.clicked.connect(self.execute_ZODB) # Triggers ZODB main function
            self.dlg.generateDBPerformanceSQLite3.clicked.connect(self.execute_SQLite3) # Triggers SQLite3 main function

            # ------------- Close Button ------------- #
            self.dlg.closeConvexHull.clicked.connect(self.close_function) # close UI
            self.dlg.closePIP.clicked.connect(self.close_function) # close UI
            self.dlg.closeEarClipping.clicked.connect(self.close_function) # close UI
            self.dlg.closeLaserData.clicked.connect(self.close_function) # close UI
            self.dlg.closeDTM.clicked.connect(self.close_function) # close UI

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            
            pass
